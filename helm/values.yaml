# LDAPGuard Helm Chart Values
# Customize your deployment by modifying these values

# Global settings
global:
  # Namespace where LDAPGuard will be deployed
  # Note: Set in ArgoCD or via --namespace flag, not here
  # namespace: ldapguard
  
# Images configuration
images:
  api:
    repository: ghcr.io/keundokki/ldapguard-api
    tag: "0.0.7"
    pullPolicy: IfNotPresent
  worker:
    repository: ghcr.io/keundokki/ldapguard-worker
    tag: "0.0.7"
    pullPolicy: IfNotPresent
  web:
    repository: ghcr.io/keundokki/ldapguard-web
    tag: "0.0.7"
    pullPolicy: IfNotPresent
  postgres:
    repository: postgres
    tag: "16-alpine"
    pullPolicy: IfNotPresent
  redis:
    repository: redis
    tag: "7-alpine"
    pullPolicy: IfNotPresent

# Image pull secrets (if using private registry)
imagePullSecrets: []
# - name: ghcr-secret

# API deployment configuration
api:
  replicas: 2
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "512Mi"
      cpu: "1000m"

# Worker deployment configuration
worker:
  replicas: 1  # Keep at 1 (APScheduler - multiple replicas would duplicate jobs)
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "512Mi"
      cpu: "1000m"

# Web (Nginx) deployment configuration
web:
  replicas: 2
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "128Mi"
      cpu: "200m"

# PostgreSQL StatefulSet configuration
postgres:
  replicas: 1
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "1Gi"
      cpu: "1000m"
  storage:
    size: "10Gi"
    # Optional: specify storageClass
    # storageClassName: "standard"
    accessMode: ReadWriteOnce

# Redis StatefulSet configuration
redis:
  replicas: 1
  resources:
    requests:
      memory: "64Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "500m"
  storage:
    size: "1Gi"
    # Optional: specify storageClass
    # storageClassName: "standard"
    accessMode: ReadWriteOnce

# Backup storage configuration
backup:
  # Enable backup volume (requires ReadWriteMany storage - NFS, CephFS, etc.)
  enabled: false
  storage:
    size: "50Gi"
    # storageClassName: "nfs-client"  # Must support ReadWriteMany
    accessMode: ReadWriteMany

# Secrets configuration
secrets:
  # Name of the secret
  name: ldapguard-secrets
  
  # Create secret from values below (NOT RECOMMENDED for production)
  # For production, set create: false and create secret manually:
  # kubectl create secret generic ldapguard-secrets \
  #   --from-literal=POSTGRES_PASSWORD="..." \
  #   --from-literal=SECRET_KEY="..." \
  #   --from-literal=ENCRYPTION_KEY="..." \
  #   --from-literal=DATABASE_URL="..." \
  #   -n ldapguard
  create: false
  
  # Secret values (only used if create: true)
  # WARNING: Do not commit real secrets to Git!
  values:
    # PostgreSQL password (generate with: openssl rand -base64 24)
    POSTGRES_PASSWORD: ""
    
    # JWT token secret key (generate with: openssl rand -base64 32)
    SECRET_KEY: ""
    
    # AES-256 encryption key for LDAP passwords (generate with: openssl rand -base64 32)
    ENCRYPTION_KEY: ""
    
    # Database connection URL
    # Replace PASSWORD with the POSTGRES_PASSWORD value above
    DATABASE_URL: "postgresql+asyncpg://ldapguard:PASSWORD@postgres:5432/ldapguard"

# Ingress configuration (Traefik)
ingress:
  enabled: false
  # Domain for your LDAPGuard instance
  domain: ldapguard.example.com
  
  # TLS Configuration
  tls:
    # Option 1: Use Traefik's ACME cert resolver (Let's Encrypt)
    # Set certResolver AND leave secretName empty
    certResolver: letsencrypt  # or 'cloudflare' if using Cloudflare DNS challenge
    
    # Option 2: Use existing TLS secret (e.g., Cloudflare Origin Certificate)
    # Set secretName AND leave certResolver empty
    secretName: ""  # e.g., "cloudflare-origin-cert"
    
    # Optional: Additional domains for certificate (SANs)
    # domains:
    #   - main: ldapguard.example.com
    #     sans:
    #       - "*.example.com"
  
  # Annotations (optional)
  annotations: {}
    # For Cloudflare: Set SSL/TLS mode to "Full (strict)" in Cloudflare dashboard

# Network Policy
networkPolicy:
  enabled: true
  # Additional ingress rules (optional)
  additionalIngressRules: []

# Service configuration
service:
  web:
    type: ClusterIP
    port: 80
  api:
    type: ClusterIP
    port: 8000
  postgres:
    type: ClusterIP
    port: 5432
  redis:
    type: ClusterIP
    port: 6379

# Application configuration (environment variables)
config:
  debug: "false"
  backupRetentionDays: "30"
  incrementalBackupEnabled: "true"
  prometheusEnabled: "true"
  prometheusPort: "9090"
  accessTokenExpireMinutes: "30"
  webhookEnabled: "false"
  # Additional environment variables for API/Worker
  extraEnv: []
  # - name: CUSTOM_VAR
  #   value: "custom-value"

# Node affinity and tolerations (optional)
affinity: {}
tolerations: []
nodeSelector: {}
