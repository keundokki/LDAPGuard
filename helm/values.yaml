# LDAPGuard Helm Chart Values
# Customize your deployment by modifying these values

# Global settings
global:
  # Namespace where LDAPGuard will be deployed
  # Note: Set in ArgoCD or via --namespace flag, not here
  # namespace: ldapguard
  
# Images configuration
images:
  api:
    repository: ghcr.io/keundokki/ldapguard-api
    tag: "0.0.7"
    pullPolicy: IfNotPresent
  worker:
    repository: ghcr.io/keundokki/ldapguard-worker
    tag: "0.0.7"
    pullPolicy: IfNotPresent
  web:
    repository: ghcr.io/keundokki/ldapguard-web
    tag: "0.0.7"
    pullPolicy: IfNotPresent
  postgres:
    repository: postgres
    tag: "16-alpine"
    pullPolicy: IfNotPresent
  redis:
    repository: redis
    tag: "7-alpine"
    pullPolicy: IfNotPresent

# Image pull secrets (if using private registry)
imagePullSecrets: []
# - name: ghcr-secret

# API deployment configuration
api:
  replicas: 2
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "512Mi"
      cpu: "1000m"

# Worker deployment configuration
worker:
  replicas: 1  # Keep at 1 (APScheduler - multiple replicas would duplicate jobs)
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "512Mi"
      cpu: "1000m"

# Web (Nginx) deployment configuration
web:
  replicas: 2
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "128Mi"
      cpu: "200m"

# PostgreSQL StatefulSet configuration
postgres:
  replicas: 1
  resources:
    requests:
      memory: "256Mi"
      cpu: "250m"
    limits:
      memory: "1Gi"
      cpu: "1000m"
  storage:
    size: "10Gi"
    # Optional: specify storageClass
    # storageClassName: "standard"
    accessMode: ReadWriteOnce

# Redis StatefulSet configuration
redis:
  replicas: 1
  resources:
    requests:
      memory: "64Mi"
      cpu: "100m"
    limits:
      memory: "256Mi"
      cpu: "500m"
  storage:
    size: "1Gi"
    # Optional: specify storageClass
    # storageClassName: "standard"
    accessMode: ReadWriteOnce

# Backup storage configuration
backup:
  # Enable backup volume (requires ReadWriteMany storage - NFS, CephFS, etc.)
  enabled: false
  storage:
    size: "50Gi"
    # storageClassName: "nfs-client"  # Must support ReadWriteMany
    accessMode: ReadWriteMany

# Secrets configuration
# IMPORTANT: Create secrets manually before deployment:
# kubectl create secret generic ldapguard-secrets \
#   --from-literal=POSTGRES_PASSWORD="$(openssl rand -base64 24)" \
#   --from-literal=SECRET_KEY="$(openssl rand -base64 32)" \
#   --from-literal=ENCRYPTION_KEY="$(openssl rand -base64 32)" \
#   --from-literal=DATABASE_URL="postgresql+asyncpg://ldapguard:PASSWORD@postgres:5432/ldapguard" \
#   -n ldapguard
secrets:
  # Name of the secret (must match the one you create)
  name: ldapguard-secrets
  # If you want Helm to create the secret (NOT RECOMMENDED for production)
  # create: false
  # values:
  #   POSTGRES_PASSWORD: ""
  #   SECRET_KEY: ""
  #   ENCRYPTION_KEY: ""
  #   DATABASE_URL: ""

# Ingress configuration (Traefik)
ingress:
  enabled: false
  # Domain for your LDAPGuard instance
  domain: ldapguard.example.com
  # TLS certificate resolver (for Let's Encrypt)
  certResolver: letsencrypt
  # Annotations (optional)
  annotations: {}
    # cert-manager.io/cluster-issuer: letsencrypt-prod

# Network Policy
networkPolicy:
  enabled: true
  # Additional ingress rules (optional)
  additionalIngressRules: []

# Service configuration
service:
  web:
    type: ClusterIP
    port: 80
  api:
    type: ClusterIP
    port: 8000
  postgres:
    type: ClusterIP
    port: 5432
  redis:
    type: ClusterIP
    port: 6379

# Application configuration (environment variables)
config:
  debug: "false"
  backupRetentionDays: "30"
  incrementalBackupEnabled: "true"
  prometheusEnabled: "true"
  prometheusPort: "9090"
  accessTokenExpireMinutes: "30"
  webhookEnabled: "false"
  # Additional environment variables for API/Worker
  extraEnv: []
  # - name: CUSTOM_VAR
  #   value: "custom-value"

# Node affinity and tolerations (optional)
affinity: {}
tolerations: []
nodeSelector: {}
